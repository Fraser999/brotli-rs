Analysis of afl-04.compressed:
0x9d 0x82 0x82 0x82 0x00 0x20 0x82 0x82 0x82 0x82 … 0x82 … 0x82 0x00 0xe6 0x00 0xe2
0xe2 0xe2 0xe2 0xe2 0xe2 0xe2 0x00 0x00 0x00 0x82 0x82 0x80 0x00 0x0d 0x23 0x00
0x82 0x82 0x00 0x82 0x82 0x82 0x00 0x0d 0x9b 0x30

Brotli Stream Header
====================
0x9d = 1001 1101

1101                # WBITS => decodes to 23
                    # window size = (1 << WBITS) - 16

Brotli Meta-Block Header
========================

1                   # ISLAST => true
0                   # ISLASTEMPTY => false
10                  # MNIBBLES => 6

0x82 0x82 0x82      # MLEN - 1 = 8553090 => MLEN = 8553091

0x00 = 0000 0000

0                   # NBLTYPESL = 1
0                   # NBLTYPESI = 1
0                   # NBLTYPESD = 1
00                  # NPOSTFIX = 0

0x20 = 0010 0000 [000]
0000                # NDIRECT = 0 << 0 == 0
00                  # CMODESL = [0]
0                   # NTREESL = 1
0                   # NTREESD = 1

0x82 = 1000 0010 [001]

                    # prefix code literals
                    # alphabet size 256
01                  # simple prefix code
00                  # NSYM - 1 == 0 => NSYM == 1

0x82 = 1000 0010 [1000 001]

0100 0001           # symbol 0x41 = 65

                    # prefix code insert-and-copy lengths
                    # alphabet size 704
01                  # simple prefix code
00                  # NSYM - 1 == 0 => NSYM == 1

0x82 = 1000 0010 [100]

00 0001 0100        # symbol 0x014 = 20

0x82 = 1000 0010 [1]

                    # prefix code distances
                    # alphabet size 16 + 0 + (48 << 0) = 64
01                  # simple prefix code
01                  # NSYM - 1 == 1 => NSYM == 2

0x82 = 1000 0010 [1000 0]

01 0000             # symbol 0x10 = 16
00 0001             # symbol 0x01 = 1

[1]

[no bits consumed]  # insert-and-copy length code 20
                    # insert length code = 2
                    # copy length code = 4
[no bits consumed]  # 2 * literal 65
1                   # distance code 16



0                   # insert-and-copy length code 321
                    # insert length code = 8
                    # copy length code = 9
11                  # 2 extra bits insert length = 3 => 13

0x21 = 0010 0001

1                   # 1 extra bit copy length = 1 => 13
[no bits consumed]  # 13 * literal 0x0c
0                   # distance code 0
0                   # insert-and-copy length code 321
                    # insert length code = 8
                    # copy length code = 9
00                  # 2 extra bits insert length = 0 => 10
1                   # 1 extra bit copy length = 1 => 13
[no bits consumed]  # 10 * literal 0x0c
0                   # distance code 0
0                   # insert-and-copy length code 321
                    # insert length code = 8
                    # copy length code = 9

0x3d = 0011 1101

01                  # 2 extra bits insert length = 1 => 11
1                   # 1 extra bit copy length = 1 => 13
[no bits consumed]  # 11 * literal 0x0c
11                  # distance code 2
1                   # insert-and-copy length code 543
                    # insert length code = 8
                    # copy length code = 9

[Ending analysis here. It turns out that this file just keeps
 accumulating literals until it goes over the very high limit
 of mlean. That will always take a while.]

